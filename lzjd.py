"""
Python implementation of Lempel Ziv Jaccard Distance


"""

import mmh3
import heapq

class LZJD_Hashifier:
    def __init__(self, k=1024):
        self.k = k

    def build_lz_set(self, buffer):
        """ Takes a buffer of bytes and returns a set of byte sequences using a modified Lempel Ziv algorithm

        :param buffer: Sequence of bytes
        :return: Lempel Ziv dictionary set
        """
        lzset = set([])
        start_index = 0
        end_index = 1
        while end_index < len(buffer):
            if buffer[start_index:end_index] not in lzset:
                lzset.add(buffer[start_index:end_index])
                start_index = end_index
            end_index = end_index + 1
        return lzset

    def get_min_hashes(self, lzset):
        """   Takes a set of byte sequences generated by build_lz_set(), hashes each item in the set, and returns the
        k smallest hashes

        :param lzset: Lempel Ziv dictionary set
        :return: set of k min-hashes
        """
        return set(heapq.nsmallest(self.k, [mmh3.hash(x, signed=False) for x in lzset]))

    def get_signature(self, min_hashes):
        """  Generates a string from a set of min-hashes that is suitable for storage in a text file or other easily
        transmitted storage medium, such as a database table.  String size will be k * 8.  Default is 8k

        :param min_hashes: Set of min-hashes generated by get_min_hashes()
        :return: signature string
        """
        return ''.join(['{:02x}'.format(x).zfill(8) for x in min_hashes])

    def get_min_hashes_from_signature(self, signature):
        """  Given a signature text generated by get_signature, convert it back into a set for processing

        :param signature: String of bytes containing a LZJD signature
        :return: set of min-hashes
        """
        return set([int(signature[i:i+8], 16) for i in range(0, len(signature), 8)])


def compare_buffers(buff1, buff2):
    """  Given two buffers of bytes, return the Jaccard distance between their LZ sets.  Distance will be a number
    between 0-1, where 0 means the sequences are the same

    :param buff1: Buffer of bytes
    :param buff2: Buffer of bytes
    :return: Jaccard distance
    """
    hasher = LZJD_Hashifier()
    setA = hasher.get_min_hashes(buff1)
    setB = hasher.get_min_hashes(buff2)
    return 1 - len(setA.intersection(setB)) / len(setA.union(setB))


def compare_file_to_signature(signature, filename):
    """  Given a signature and a filename, return the Jaccard distance between their LZ sets.  Distance will be a number
    between 0-1, where 0 means the sequences are the same

    :param signature: String of bytes containing an LZJD signature
    :param filename: Path to the file to compare against the signature
    :return: Jaccard distance
    """
    hasher = LZJD_Hashifier()
    setA = hasher.get_min_hashes_from_signature(signature)
    setB = hasher.get_min_hashes(open(filename, "rb"))
    return 1 - len(setA.intersection(setB)) / len(setA.union(setB))


def compare_signatures(signature1, signature2):
    """  Given 2 signatures, return the Jaccard distance between their LZ sets.  Distance will be a number
    between 0-1, where 0 means the sequences are the same

    :param signature1: String of bytes containing an LZJD signature
    :param signature2: String of bytes containing an LZJD signature
    :return: Jaccard distance
    """
    hasher = LZJD_Hashifier()
    setA = hasher.get_min_hashes_from_signature(signature1)
    setB = hasher.get_min_hashes_from_signature(signature2)
    return 1 - len(setA.intersection(setB)) / len(setA.union(setB))


if __name__ == "__main__":
    file1 = "c://Windows/System32/calc.exe"
    file2 = "c://Windows/System32/cmd.exe"
    hasher = LZJD_Hashifier()
    test = hasher.get_min_hashes(open(file1, "rb"))
    print(test)
    test2 = hasher.get_signature(hasher.get_min_hashes(open(file1, "rb")))
    print(test2)
    print(compare_file_to_signature(test2, file1))
    print(compare_file_to_signature(test2, file2))